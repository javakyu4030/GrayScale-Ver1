<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC 3</title>

    <script lang="javascript">
        // =================================================================전역 변수부===================================================================
        var inCanvas, outCanvas, inCtx, outCtx, inPaper, outPaper //화면관련
        var inFile;
        var inImage, outImage;    //입력, 출력이미지(2차원 배열)
        var inH, inW, outH, outW;  //입력 영상, 출력 영상의 높이 X 폭 

    </script>
    <script lang="javascript">
        // =================================================================공통함수 선언부===================================================================
        function init() {    //초기화 함수
            inCanvas = document.getElementById('inCanvas'); //도화지에 접근
            outCanvas = document.getElementById('outCanvas'); //도화지에 접근
            inCtx = inCanvas.getContext('2d');    //물감, 붓이 들은 통
            outCtx = outCanvas.getContext('2d');    //물감, 붓이 들은 통
        }

        function openImage() {
            inFile = document.getElementById("inFile").files[0];     //선택한 파일   /var가 없어야 전역변수꺼로 지정
            //(!중요) 이미지의 크기를 확인
            inH = inW = Math.sqrt(inFile.size);
            //영상 크기의 2차원 메모리 확보
            inImage = new Array(inH);
            for (var i = 0; i < inH ; i++)
                inImage[i] = new Array(inW);
            //캔버스 크기 지정
            inCanvas.height = inH;
            inCanvas.width = inW;
            //파일 -->메모리
            var reader = new FileReader();  //파일의 내용을 (혹은 raw data)읽고 사용자의 컴퓨터에 저장하는것이 가능
            reader.readAsBinaryString(inFile);  //파일을 읽기 위해
            reader.onload = function () {   //onload -> 전체 페이지에 모든 외부리소스나 이미지가 전부 불러와진 이후에 작동
                var blob = reader.result;   //파일을 한 덩어리(blob)로 가져옴
               //document.write(typeof blob);
               
                //덩어리(blob)에서 한점한점 뽑아서 , 우리 배열(inImage)에 넣기
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        var sPixel = (i * inH + k); //시작 위치
                        var ePixel = (i * inH + k) + 1; //끝 위치
                        inImage[i][k] = blob.slice(sPixel, ePixel).charCodeAt(0); //0~1까지 뽑기: 0만 뽑힘//1차원을 2차원으로 만드는 기법//'꿹'을 읽어옴
                    }
                    }
                //** 입력 메모리를 페이퍼에 출력한 후, 페이퍼를 캔버스에 붙이기 **
                 inPaper = inCtx.createImageData(inH, inW); // 종이를 준비하기
                    for(var i=0; i<inH; i++) {
                        for (var k=0; k<inW; k++) {
                            var px = inImage[i][k]; //'뙓'을 숫자(129)로 변경
                            inPaper.data[ (i*inH + k)*4 + 0 ] = px; // Red
                            inPaper.data[ (i*inH + k)*4 + 1 ] = px; // Green
                            inPaper.data[ (i*inH + k)*4 + 2 ] = px; // Blue
                            inPaper.data[ (i*inH + k)*4 + 3 ] = 255; // Alpha
                        }
                    }
                    inCtx.putImageData(inPaper,0,0); // 종이를 캔버스 (0,0)에 붙이기 (왼쪽위 딱 붙여서)
                    }
                }

                function display() {
                        //**출력 메모리의 내용을 화면에 출력하기.**
                        outPaper = outCtx.createImageData(outH, outW);    //종이 준비하기
                        //캔버스 크기 지정
                        outCanvas.height = outH;
                        outCanvas.width = outW;
                
                    for (var i = 0; i < outH; i++) {
                        for (var k = 0; k < outW; k++) {
                            var pix = outImage[i][k];   //(깨지는 파일에서)'뙓'을 숫자 (예)129)로 변경
                            //**진짜 핵심 알고리즘
                            outPaper.data[(i * outW + k) * 4 + 0] = pix; // red
                            outPaper.data[(i * outW + k) * 4 + 1] = pix; // Green
                            outPaper.data[(i * outW + k) * 4 + 2] = pix; // Blue
                            outPaper.data[(i * outW + k) * 4 + 3] = 255; // Alpha
                            /////////////////////////
                        }
                    }
                    outCtx.putImageData(outPaper, 0, 0); // 종이를 캔버스 (0,0)에 붙이기 (왼쪽위 딱 붙여서)
                }


    </script>
    <script lang="javascript">
        //================================================================영상처리 함수부====================================================================

        function selectAlgorithm(selectNum){
            switch (parseInt(selectNum.value)){
                //-----------------------화소점 --------------------        
                case 101 : // 동일영상
                    equalImage();
                    break;
                case 102 : // 영상반전
                    reverseImage();
                    break;
                case 103 : // 영상밝기
                    addImage();
                    break;
                case 104 : // 파라볼라(캡)
                    paraCap();
                    break;
                //-----------------------기하학 --------------------        
                case 201 : // 상하미러링
                    verticalReverse();
                    break;
                case 202 : // 좌우미러링
                    horizenReverse();
                    break;
                case 203 : // 영상 축소
                    zoomOutImage();
                    break;
                case 204 : // 영상 확대
                    zoomInImage();
                    break;
                case 205 : // 영상 90도 오른쪽회전 
                    rotateR();
                    break;
                case 206 : // 영상 90도 왼쪽회전 
                    rotateL();
                    break;
                //-----------------------히스토그램 --------------------        
                case 301 : // 히스토그램 스트래칭
                    histoStretch();
                    break;
                case 302 : // 앤드인
                    endIn();
                    break;
                case 303 : // 히스토그램 평활화
                    histoEqual();
                    break;
                
                //-----------------------화소영역 --------------------        
                case 401 : // 엠보싱
                    embossing();
                    break;
                case 402 : // 블러링1
                    blurring1();
                    break;
                case 403 : // 블러링2
                    blurring2();
                    break;
                case 404 : // 블러링3
                    blurring3();
                    break;
                case 405 : //고주파 필터
                    highFre();
                    break;
                case 406 : // 가우시안
                    gaussian();
                    break;
                case 407 : // 샤프닝
                    sharpening();
                    break;
                //-----------------------경계선 --------------------        
                case 501 : // 엣지1(유사연산자)
                    edge1();
                    break;
                case 502 : // 엣지1(차연산자)
                    edge2();
                    break;
                case 503 : // 라플라시안
                    laplacian();
                    break;
                case 504 : // 도그
                    dog();
                    break;
                case 505 : // 프리잇
                    prewitt();
                    break;
               /*
                case 506 : // 저주파
                     lowFrequency();
                    break;
                */
              
            }
                
           /* alert()*/
        }

        //====================================================화소점=========================================
             //---------------동일 영상 출력--------------
            function equalImage() { //동일영상
                // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                //**영상처리 알고리즘 구현
                
                for (var i = 0; i < inH; i++) {
                            for (var k = 0; k < inW; k++) {

                            outImage[i][k] = inImage[i][k];
                            }
                        }
                        display();
                }
             //---------------영상 반전--------------
             function reverseImage() {   //영상 반전
            // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                
                //** 영상처리 알고리즘 구현
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        outImage[i][k] = 255-inImage[i][k];
                    }
                }
                display();
            }
            
            //---------------밝기--------------
            function addImage() {// 밝게하기 //영상 덧셈 알고리즘
                // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                //**영상처리 알고리즘 구현
                
                var value = parseInt(prompt("숫자:","0"));
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        var px =inImage[i][k];
                        
                        if(px + value > 255)
                        px =255;
                        else
                        px = px + value;
                        outImage[i][k] = px;
                    }
                }
                display();
            }
            //---------------밝기조절 ->레인지--------------
            function addImageRange() {// 밝게하기 //영상 덧셈 알고리즘
                // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                //**영상처리 알고리즘 구현
                
                var value = parseInt(document.getElementById("addImage2").value);
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        var px =inImage[i][k];
                        
                        if(px + value > 255)
                        px =255;
                        else
                        px = px + value;
                        outImage[i][k] = px;
                    }
                }
                display();
            }
            //---------------파라볼라--------------
            function paraCap() { //파라볼라 (Cap)
            // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
            outH = inH;
            outW = inW;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                 outImage[i] = new Array(outW);
            //**영상처리 알고리즘 구현
            // outV = 255 * (inV / 127 -1 )* (inV / 127 -1 )
            //★★★lookUp Table  --> 계산식을 미리 해놓음으로써 CPU 향상
            var LUT = new Array(256);
            for(var i=0; i<256; i++){
                var outV = 255 * (i / 127 - 1 ) * (i / 127 - 1 );
                if(outV < 0)
                    outV = 0;
                if(outV > 255)
                    outV = 255;
                LUT[i] = outV;
            }
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                        outImage[i][k] =  LUT[inImage[i][k]];
                }
            }
            display();
            }
            
        //====================================================기하학=========================================
        //---------------상하 반전--------------
        function verticalReverse() { //상하반전
            // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
            outH = inH;
            outW = inW;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                    outImage[i] = new Array(outW);
                    //**영상처리 알고리즘 구현

                    for (var i = 0; i < inH/2; i++) {
                        for (var k = 0; k < inW; k++) {
                            tmp = inImage[i][k];
                        inImage[i][k] = inImage[inH-i-1][k];
                        inImage[inH-i-1][k] = tmp;
                    }
                }
            
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        outImage[i][k] = inImage[i][k];
                
                    }
                }
                
                display();
            }
            
            //---------------좌우 반전--------------
            function horizenReverse() { //좌우반전
                // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                //**영상처리 알고리즘 구현
                
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW/2; k++) {
                        tmp = inImage[i][k];
                        inImage[i][k] = inImage[i][inW-k-1];
                        inImage[i][inW-k-1] = tmp;
                    }
                }
                
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        outImage[i][k] = inImage[i][k];
                        
                    }
                }
                
                display();
            }
            
            //---------------영상 축소--------------
            function zoomOutImage() { //영상 축소 알고리즘
                //zoom ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                var scale = parseInt(prompt("축소배율(짝수):","2"));
                outH = inH / scale;
                outW = inW / scale;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                
                //**진짜 영상 처리(확대축소) 알고리즘
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        //******핵심 알고리즘(영상 축소)
                        outImage[parseInt(i/scale)][parseInt(k/scale)]  = inImage[i][k];
                        
                    }
                }
                
                display();
            }
            
            //---------------영상 확대--------------
            function zoomInImage() { //영상 확대 ★★★백워딩 기법으로 채워야 Hole(빈공간) 문제를 해결 할 수 있음
                // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                var scale = parseInt(prompt("확대배율(짝수):","2"));
                outH = inH * scale;     //영상의 폭높이를 입력 값의 비율에 맞춰서 증가
                outW = inW * scale;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)    
                outImage[i] = new Array(outW);
                
                //**진짜 영상 처리(확대축소) 알고리즘
                for (var i = 0; i <outH; i++) {          // 정방향 방법 --> 배열의 길이를 (outH)출력 길이로      //역방향 방법일 경우 -->배열의 길이(inH)로 
                    for (var k = 0; k < outW; k++) {
                        //******핵심 알고리즘(영상 축소)***********
                        
                        //outImage[parseInt(i*scale)][parseInt(k*scale)] = inImage[i][k];   // 정방향 방법 -> hole 발생
                        outImage [i][k]= inImage[parseInt(i/scale)][parseInt(k/scale)]; // 백워딩 기법 (input배열의 인덱스 곱셈을 통해 값을 넣으면 --> hole (빈공간) 문제 발생) / 먼저 확장된 배열의 인덱스를 배열의 확대값으로 나눈몫의 값 숫자의 인덱스 값을 원본이미지의 배열 인덱스 값을 불러옴
                        
                    }
                }
                
                display();
            }
            //---------------영상 확대  ->스크롤--------------
            function zoomRange() { //영상 확대 ★★★백워딩 기법으로 채워야 Hole(빈공간) 문제를 해결 할 수 있음
                // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                var scale = parseFloat(document.getElementById("zommRange1").value);
                outH = parseInt(inH * scale);     //영상의 폭높이를 입력 값의 비율에 맞춰서 증가
                outW = parseInt(inW * scale);
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)    
                outImage[i] = new Array(outW);
                
                //**진짜 영상 처리(확대축소) 알고리즘
                for (var i = 0; i <outH; i++) {          // 정방향 방법 --> 배열의 길이를 (outH)출력 길이로      //역방향 방법일 경우 -->배열의 길이(inH)로 
                    for (var k = 0; k < outW; k++) {
                        //******핵심 알고리즘(영상 축소)***********
                        
                        //outImage[parseInt(i*scale)][parseInt(k*scale)] = inImage[i][k];   // 정방향 방법 -> hole 발생
                        outImage [i][k]= inImage[parseInt(i/scale)][parseInt(k/scale)]; // 백워딩 기법 (input배열의 인덱스 곱셈을 통해 값을 넣으면 --> hole (빈공간) 문제 발생) / 먼저 확장된 배열의 인덱스를 배열의 확대값으로 나눈몫의 값 숫자의 인덱스 값을 원본이미지의 배열 인덱스 값을 불러옴
                        
                    }
                }
                
                display();
            }
            /*
            function rotateR() { //회전 기능
                // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
            outW = inW;
            var tmpArray = outImage;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                    outImage[i] = new Array(outW);
                    //**영상처리 알고리즘 구현
                    
                    
                    for (var i = 0; i < inH; i++) {
                        for (var k = 0; k < inW; k++) {
                            outImage[i][k] = tmpArray[outH-k-1][i];
                            
                    }
                }
                
                display();
            }
            */
            //---------------오른쪽 90 회전--------------
           function rotateR() { //영상 90도 오른쪽 회전
               // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~   //직접 표를 그려보며 이해
               outH = inH;
               outW = inW;
               outImage = new Array(outH);
               for(var i=0; i<outH; i++)
                 outImage[i] =  new Array(outW);
                
                for(var i=0; i<inH; i++){
                    for(var k = 0; k<inW; k++){
                        outImage[k][(inH-i-1)] = inImage[i][k];
             
                    }
                }
                display();
            }
             //---------------왼쪽 90 회전--------------
            function rotateL() { //영상 90도 왼쪽 회전
                // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                outImage = new Array(inH);
                for(var i=0; i<inH; i++)
                outImage[i] =  new Array(inW);
                 

                 for(var i=0; i<inH; i++){
                     for(var k=0; k<inW; k++){
                         outImage[i][k] = inImage[k][(inH-i-1)];
                     }
                 }
                 display();
             }
            
               
        //        //영상 크기의 2차원 메모리 확보
        //        outImage = new Array(outH);
        //        for (var i = 0; i < outH; i++)    
        //        outImage[i] = new Array(outW);
               
        //        //**진짜 영상 처리(확대축소) 알고리즘
        //        for (var i = 0; i <outH; i++) {          // 정방향 방법 --> 배열의 길이를 (outH)출력 길이로      //역방향 방법일 경우 -->배열의 길이(inH)로 
        //            for (var k = 0; k < outW; k++) {
        //                //******핵심 알고리즘(영상 축소)***********
                       
        //                //outImage[parseInt(i*scale)][parseInt(k*scale)] = inImage[i][k];   // 정방향 방법 -> hole 발생
        //                outImage [i][k]= inImage[parseInt(i/scale)][parseInt(k/scale)]; // 백워딩 기법 (input배열의 인덱스 곱셈을 통해 값을 넣으면 --> hole (빈공간) 문제 발생) / 먼저 확장된 배열의 인덱스를 배열의 확대값으로 나눈몫의 값 숫자의 인덱스 값을 원본이미지의 배열 인덱스 값을 불러옴
                       
        //            }
        //        }
               
        //        display();
        //    }


           //====================================================히스토그램=========================================
            //---------------히스토그램--------------
           function histoStretch() { //히스토그램 스트레치
            // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
            outH = inH;
            outW = inW;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
            outImage[i] = new Array(outW);
            
            //**영상처리 알고리즘 구현
            //out =  (in - minValue)/(maxValue (영상에서 제일 밝은값)-minValue(영상에서 제일 어두운값)*255
            var minValue = inImage[0][0];   //최소값    ★그 영역에 있는 맨 앞에 값으로 초기화-> 버그 안생기게 하려고
            var maxValue = inImage[0][0];   //최대값    ★그 영역에 있는 맨 앞에 값으로 초기화-> 버그 안생기게 하려고
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] < minValue)
                                minValue = inImage[i][k];
                        }   
                            if (inImage[i][k] > maxValue)
                                    maxValue = inImage[i][k];
                        }   
                    
                //outValue =  (inValue - minValue)/(maxValue-minValue)*255
            for (var i = 0; i < inH; i++) {
                        for (var k = 0; k < inW; k++) {
                        var inValue = inImage[i][k];
                        var outValue = (inValue-minValue)/(maxValue-minValue) *255.0;
                        if(outValue < 0)
                                outValue = 0
                        if(outValue >255)
                                outValue = 255
                        outImage[i][k] = (inImage[i][k]-minValue)/(maxValue-minValue);

                        outImage[i][k] = outValue;
                        }
                    }
                    display();
            }
            
             //--------------앤드인--------------
            function endIn() { //앤드인     ->  선명해지지만 데이터의 값을 잃어 버림
            // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
            outH = inH;
            outW = inW;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
            outImage[i] = new Array(outW);
            
            //**영상처리 알고리즘 구현
            //out =  (in - minValue)/(maxValue (영상에서 제일 밝은값)-minValue(영상에서 제일 어두운값)*255
            var minValue = inImage[0][0];   //최소값    ★그 영역에 있는 맨 앞에 값으로 초기화-> 버그 안생기게 하려고
            var maxValue = inImage[0][0];   //최대값    ★그 영역에 있는 맨 앞에 값으로 초기화-> 버그 안생기게 하려고
            for (var i = 0; i < inH; i++) {
                        for (var k = 0; k < inW; k++) {
                            if (inImage[i][k] < minValue)
                                minValue = inImage[i][k];
                        }   
                            if (inImage[i][k] > maxValue)
                                    maxValue = inImage[i][k];
                        }   

                        minValue = minValue + 50;
                        maxValue = maxValue - 50;
                //outValue =  (inValue - minValue)/(maxValue-minValue)*255
            for (var i = 0; i < inH; i++) {
                        for (var k = 0; k < inW; k++) {
                        var inValue = inImage[i][k];
                        var outValue = (inValue-minValue)/(maxValue-minValue) *255.0;
                        if(outValue < 0)
                                outValue = 0
                        if(outValue > 255)
                                outValue = 255
                        outImage[i][k] = (inImage[i][k]-minValue)/(maxValue-minValue);

                        outImage[i][k] = outValue;
                        }
                    }
                    display();
            }
             //---------------히스토 그램--------------
            function histoEqual() { //히스토 그램 -> 뭉쳐있는 부분을 쭉 펴주는 기능
            // 중요 ! 출력 영상의 크기를 결정 --> 알고리즘에 의존~  사진마다 효과 다름 ->AVE256.RAW 이게 제일 효과
            outH = inH;
            outW = inW;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
            outImage[i] = new Array(outW);
            //**영상처리 알고리즘 구현
            //1단계 : 히스토그램 (막대그래프 = 빈도수 카운트)
            var histo =  new Array(256);
            for(var i=0; i<256; i++)//초기화
                histo[i]=0;
              for(var i=0; i<inH; i++)  {
                for(var k=0;k<inW; k++){
                    histo[inImage[i][k]]++; // --> 빈도수 카운트
                }
            }
            // 2단계 : 누적 히스토그램
            var sumHisto = new Array(256);
            for (var i=0; i<256;i++)// 초기화 0
            sumHisto[i] = 0;
            var sumValue = 0;
            for (var i=0; i<256; i++){
                sumValue += histo[i];
                sumHisto[i] = sumValue;
            }
            //3단계 : 정규화된 누적 히스토그램
            //n = sumHisto * (1 / 총픽셀수)* 최대픽셀 밝기
            var normalHisto = new Array(256);
            for (var i=0; i<256; i++)
                normalHisto[i] = 0;
            for (var i=0; i<256; i++)
                normalHisto[i] = sumHisto[i] * (1 / (inH*inW)) * 255;   
                //최종 : 정규화된 히스토그램을 적용해서 픽셀값 변환
                for(var i=0; i<inH; i++){
                for(var k=0;k<inW;k++){
                    outImage[i][k] = parseInt(normalHisto[inImage[i][k]]);
                    
                }
            }
            display();
        }
        
        //====================================================화소영역=========================================
            //---------------엠보씽--------------
            function embossing() { //엠보씽 알고리즘
            // 중요 !마스크 준비 - 화소영역은 마스크만 달라짐
            outH = inH;
            outW = inW;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
            //**영상처리 알고리즘 구현
            //**마스크 중요!
            //자바와 다르게 자바스크립트는 3/2= 1.9  ->   자바는 1/ 자바스크립트는 1.9 나누는 그대로 값
            var mask = [  [ -1.0 , 0.0, 0.0],
                          [ 0.0 , 0.0, 0.0],
                          [ 0.0 , 0.0, 1.0]      ];
            //임시 입력배열( 입력 배열 +2(위아래))
            var tmpInImage = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInImage[i] = new Array(inW + 2);
            //임시 입력배열 초기화
            for (var i = 0; i < inH + 2; i++) {
                for (var k = 0; k < inW + 2; k++) {        
                    tmpInImage[i][k] = 127;   // 개선의 여지가 있음....
                }
            }
            //입력영상 -> 임시입력영상의 가운데 쏙~
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    tmpInImage[i+1][k+1] = inImage[i][k];
                        }
                    }           

            //임시 출력 영상 준비   -> 데이터값의 손실을 없애기 위해서 임시 출력 영상부분에서 출력전 사전 처리하기위해서
            var tmpOutImage = new Array(outH);
            for (var i = 0; i < outH ; i++)
                tmpOutImage[i] = new Array(outW);

             //**영상 처리 알고리즘 --> 회선연산
            for (var i = 0; i < inH ; i++) {
                for (var k = 0; k < inW; k++) {  
                    //한점에 대해 처리
                    var S = 0; // 9개 곱한 합
                    for(var m=0; m<3; m++)
                        for(var n=0; n<3; n++)
                            S += tmpInImage[i+m][k+n] * mask[m][n];
                    tmpOutImage[i][k] = S;

               }
            }
            //후처리 : 마스크 합이 0->+127, 마스크 합이 1--> X
            for (var i = 0; i < outH; i++) 
                    for (var k = 0; k < inW; k++) 
                            tmpOutImage[i][k] += 127;

            //임시 출력 영상 --> 출력 영상
            for (var i = 0; i < outH; i++) 
                    for (var k = 0; k < inW; k++)   
                            outImage[i][k] = parseInt(tmpOutImage[i][k]);
                          
                    display();
            
            }
            //---------------블러링1--------------
            function blurring1() { //블러링 알고리즘            //마스크를 통해서 마스크 영역의 값들의 평균과 연산하여 평탄화? 작업
                console.log(" 1번")                             //그럼 경계선 값들이 비슷해지기떄문에 흐려지는 효과를 발생
            // 중요 !마스크 준비 - 화소영역은 마스크만 달라짐
            outH = inH;
            outW = inW;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
            outImage[i] = new Array(outW);
            //**영상처리 알고리즘 구현
            //**마스크 중요!
            //자바와 다르게 자바스크립트는 3/2= 1.5  ->   자바는 1/ 자바스크립트는 1.5 나누는 그대로 값
            var mask = [  [ 1/9.0 ,  1/9.0,  1/9.0],
                          [ 1/9.0 ,  1/9.0,  1/9.0],
                          [ 1/9.0 ,  1/9.0,  1/9.0]   ];
            //임시 입력배열( 입력 배열 +2(위아래))
            var tmpInImage = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInImage[i] = new Array(inW + 2);
            //임시 입력배열 초기화
            for (var i = 0; i < inH + 2; i++) {
                for (var k = 0; k < inW + 2; k++) {        
                    tmpInImage[i][k] = 127;   // 개선의 여지가 있음....
                }
            }
            //입력영상 -> 임시입력영상의 가운데 쏙~ 
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    tmpInImage[i+1][k+1] = inImage[i][k]
                        }
                    }           

            //임시 출력 영상 준비   -> 데이터값의 손실을 없애기 위해서 임시 출력 영상부분에서 출력전 사전 처리하기위해서
            var tmpOutImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutImage[i] = new Array(outW);

             //**영상 처리 알고리즘 --> 회선연산
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {  
                    //한점에 대해 처리
                    var S = 0; // 9개 곱한 합
                    for(var m=0; m<3; m++)
                        for(var n=0; n<3; n++)
                            S += tmpInImage[i+m][k+n] * mask[m][n];

                    tmpOutImage[i][k] = S;
                   

               }
            }
            // //후처리 : 마스크 합이 0->+127, 마스크 합이 1--> X
            // for (var i = 0; i < outH; i++) {
            //         for (var k = 0; k < inH + 2; k++) {  
            //                 tmpOutImage[i][k] += 127;

            //임시 출력 영상 --> 출력 영상
            for (var i = 0; i < outH; i++) 
                    for (var k = 0; k < inW; k++)  
                            outImage[i][k] = parseInt(tmpOutImage[i][k]);
                          
                
                    display();
            }
            
            //---------------블러링2--------------
            function blurring2() { //블러링 알고리즘
            // 중요 !마스크 준비 - 화소영역은 마스크만 달라짐
            //prompt()  
            outH = inH;
            outW = inW;
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
            outImage[i] = new Array(outW);
            //**영상처리 알고리즘 구현
            //**마스크 중요!
            //자바와 다르게 자바스크립트는 3/2= 1.5  ->   자바는 1/ 자바스크립트는 1.5 나누는 그대로 값
            var mask = [  [ 1/25.0 ,  1/25.0,  1/25.0, 1/25.0, 1/25.0],
                          [ 1/25.0 ,  1/25.0,  1/25.0, 1/25.0, 1/25.0],
                          [ 1/25.0 ,  1/25.0,  1/25.0, 1/25.0, 1/25.0],
                          [ 1/25.0 ,  1/25.0,  1/25.0, 1/25.0, 1/25.0],
                          [ 1/25.0 ,  1/25.0,  1/25.0, 1/25.0, 1/25.0],   ];
            //임시 입력배열( 입력 배열 +4(위아래))
            var tmpInImage = new Array(inH + 4);
            for (var i = 0; i < inH + 4; i++)
                tmpInImage[i] = new Array(inW + 4);
            //임시 입력배열 초기화
            for (var i = 0; i < inH + 4; i++) {
                for (var k = 0; k < inW + 4; k++) {        
                    tmpInImage[i][k] = 127;   // 개선의 여지가 있음....
                }
            }
            //입력영상 -> 임시입력영상의 가운데 쏙~ 
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    tmpInImage[i+2][k+2] = inImage[i][k]
                        }
                    }           

            //임시 출력 영상 준비   -> 데이터값의 손실을 없애기 위해서 임시 출력 영상부분에서 출력전 사전 처리하기위해서
            var tmpOutImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutImage[i] = new Array(outW);

             //**영상 처리 알고리즘 --> 회선연산
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {  
                    //한점에 대해 처리
                    var S = 0; // 25개 곱한 합
                    for(var m=0; m<5; m++)
                        for(var n=0; n<5; n++)
                            S += tmpInImage[i+m][k+n] * mask[m][n];

                    tmpOutImage[i][k] = S;
                   

               }
            }
            // //후처리 : 마스크 합이 0->+127, 마스크 합이 1--> X
            // for (var i = 0; i < outH; i++) {
            //         for (var k = 0; k < inH + 2; k++) {  
            //                 tmpOutImage[i][k] += 127;

            //임시 출력 영상 --> 출력 영상
            for (var i = 0; i < outH; i++) 
                    for (var k = 0; k < inW; k++)  
                            outImage[i][k] = parseInt(tmpOutImage[i][k]);
                          
                
                    display();
            }
            
         
            //---------------블러링3-> 입력값에 따른 효과--------------

            function blurring3() { //블러링 알고리즘
                console.log(" 1번")
                
            // 중요 !마스크 준비 - 화소영역은 마스크만 달라짐
            //prompt()  
            outH = inH;
            outW = inW;
            var inputSize = parseInt(prompt("홀수입력:","3"));      //입력값에 따른 마스크 크기가 결정
            var mask = new Array(inputSize);
            console.log(" 1-1번")
            
             for(var i = 0; i < inputSize; i++){
                 mask[i] = new Array(inputSize);
             }
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);                     //출력될 영상의 크기를 설정
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
            console.log(" 1-2번")
            //**영상처리 알고리즘 구현
            //**마스크 중요!
            for (var i = 0; i <inputSize ; i++) {
                for (var k = 0; k < inputSize ; k++) {
                     mask[i][k] = 1.0 / (inputSize*inputSize);        //마스크의 평균값 구하기
               }
             }
             console.log(" 2번")
            //임시 입력배열( 입력 배열 +(위아래))   -->원본 이미지의 모서리 부분들을 처리하려고 임시배열 만들어줌
            var tmpInImage = new Array(inH + (inputSize-1));    //-1은 중앙줄 //원본배열에서 임시배열 생성된 크기만큼 추가
            for (var i = 0; i < inH + (inputSize-1); i++)
                tmpInImage[i] = new Array(inW + (inputSize-1));
            //임시 입력배열 초기화
            for (var i = 0; i < inH + (inputSize-1); i++) {
                for (var k = 0; k < inW + (inputSize-1); k++) {        
                    tmpInImage[i][k] = 127;   // 개선의 여지가 있음....
                }
            }
            //입력영상 -> 임시입력영상의 가운데
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    tmpInImage[i+Math.floor(inputSize/2)][k+Math.floor(inputSize/2)] = inImage[i][k]
                        }
                    }           
                    console.log(" 3번")
                    //임시 출력 영상 준비   -> 데이터값의 손실을 없애기 위해서 임시 출력 영상부분에서 출력전 사전 처리하기위해서
            var tmpOutImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutImage[i] = new Array(outW);
                        
            console.log(" 4번")
            //**영상 처리 알고리즘 --> 회선연산
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {  
                    //한점에 대해 처리
                    var S = 0.0; 
                    for(var m=0; m<inputSize; m++){
                        for(var n=0; n<inputSize; n++){
                            S += tmpInImage[i+m][k+n] * mask[m][n];
                            }
                        }
                    
                    tmpOutImage[i][k] = S;
                    
            
                }
            }
            // //후처리 : 마스크 합이 0->+127, 마스크 합이 1--> X
            // for (var i = 0; i < outH; i++) {
            //         for (var k = 0; k < inH + 2; k++) {  
            //                 tmpOutImage[i][k] += 127;
            console.log(" 7번")
            //임시 출력 영상 --> 출력 영상
            for (var i = 0; i < outH; i++) {
                for (var k = 0; k < outW; k++)  {
                    var v = tmpOutImage[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0.0)
                        v = 0.0;
                    outImage[i][k] = parseInt(v);   //숫자타입으로 배열에 저장
                    }   
                }   
                console.log(" 8번")
                display();
            }
            //---------------블러링--------------

            function blurringRange() { //블러링 알고리즘
                console.log(" 1번")
                
            // 중요 !마스크 준비 - 화소영역은 마스크만 달라짐
            //prompt()  
            outH = inH;
            outW = inW;
            var inputSize = parseInt(document.getElementById("blurring4").value);      //input태그 id-> blurring4 ->type="range" -> 게이지바 연동
            var mask = new Array(inputSize);
            console.log(" 1-1번")
            
             for(var i = 0; i < inputSize; i++){
                 mask[i] = new Array(inputSize);
             }
            //영상 크기의 2차원 메모리 확보
            outImage = new Array(outH);                     //출력될 영상의 크기를 설정
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
            console.log(" 1-2번")
            //**영상처리 알고리즘 구현
            //**마스크 중요!
            for (var i = 0; i <inputSize ; i++) {
                for (var k = 0; k < inputSize ; k++) {
                     mask[i][k] = 1.0 / (inputSize*inputSize);        //마스크의 평균값 구하기
               }
             }
             console.log(" 2번")
            //임시 입력배열( 입력 배열 +(위아래))   -->원본 이미지의 모서리 부분들을 처리하려고 임시배열 만들어줌
            var tmpInImage = new Array(inH + (inputSize-1));    //-1은 중앙줄 //원본배열에서 임시배열 생성된 크기만큼 추가
            for (var i = 0; i < inH + (inputSize-1); i++)
                tmpInImage[i] = new Array(inW + (inputSize-1));
            //임시 입력배열 초기화
            for (var i = 0; i < inH + (inputSize-1); i++) {
                for (var k = 0; k < inW + (inputSize-1); k++) {        
                    tmpInImage[i][k] = 127;   // 개선의 여지가 있음....
                }
            }
            //입력영상 -> 임시입력영상의 가운데
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    tmpInImage[i+Math.floor(inputSize/2)][k+Math.floor(inputSize/2)] = inImage[i][k]
                        }
                    }           
                    console.log(" 3번")
                    //임시 출력 영상 준비   -> 데이터값의 손실을 없애기 위해서 임시 출력 영상부분에서 출력전 사전 처리하기위해서
            var tmpOutImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutImage[i] = new Array(outW);
                        
            console.log(" 4번")
            //**영상 처리 알고리즘 --> 회선연산
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {  
                    //한점에 대해 처리
                    var S = 0.0; 
                    for(var m=0; m<inputSize; m++){
                        for(var n=0; n<inputSize; n++){
                            S += tmpInImage[i+m][k+n] * mask[m][n];
                            }
                        }
                    
                    tmpOutImage[i][k] = S;
                    
            
                }
            }
            // //후처리 : 마스크 합이 0->+127, 마스크 합이 1--> X
            // for (var i = 0; i < outH; i++) {
            //         for (var k = 0; k < inH + 2; k++) {  
            //                 tmpOutImage[i][k] += 127;
            console.log(" 7번")
            //임시 출력 영상 --> 출력 영상
            for (var i = 0; i < outH; i++) {
                for (var k = 0; k < outW; k++)  {
                    var v = tmpOutImage[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0.0)
                        v = 0.0;
                    outImage[i][k] = parseInt(v);   //숫자타입으로 배열에 저장
                    }   
                }   
                console.log(" 8번")
                display();
            }
          
            
            //---------------고주파--------------
            function highFre() { //고주파 알고리즘
                // 중요 !마스크 준비 - 화소영역은 마스크만 달라짐
                outH = inH;
                outW = inW;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                //**영상처리 알고리즘 구현
                //**마스크 중요!
                //자바와 다르게 자바스크립트는 3/2= 1.9  ->   자바는 1/ 자바스크립트는 1.9 나누는 그대로 값
                var mask = [  [ -1/9.0 ,  -1/9.0,  -1/9.0],
                            [ -1/9.0 ,  8/9.0,  -1/9.0],
                            [ -1/9.0 ,  -1/9.0,  -1/9.0]      ];
                //임시 입력배열( 입력 배열 +2(위아래))
                var tmpInImage = new Array(inH + 2);
                for (var i = 0; i < inH + 2; i++)
                tmpInImage[i] = new Array(inW + 2);
                //임시 입력배열 초기화
                for (var i = 0; i < inH + 2; i++) {
                    for (var k = 0; k < inW + 2; k++) {        
                        tmpInImage[i][k] = 127;   // 개선의 여지가 있음....
                    }
                }
                //입력영상 -> 임시입력영상의 가운데 쏙~
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        tmpInImage[i+1][k+1] = inImage[i][k];
                    }
                        }           

                //임시 출력 영상 준비   -> 데이터값의 손실을 없애기 위해서 임시 출력 영상부분에서 출력전 사전 처리하기위해서
                var tmpOutImage = new Array(outH);
                for (var i = 0; i < outH ; i++)
                    tmpOutImage[i] = new Array(outW);
                    
                    //**영상 처리 알고리즘 --> 회선연산
                    for (var i = 0; i < inH; i++) {
                        for (var k = 0; k < inW; k++) {  
                            //한점에 대해 처리
                            var S = 0; // 9개 곱한 합
                            for(var m=0; m<3; m++)
                            for(var n=0; n<3; n++)
                            S += tmpInImage[i+m][k+n] * mask[m][n];

                        tmpOutImage[i][k] = S;
                        
                        
                    }
                }
                //후처리 : 마스크 합이 0->+127, 마스크 합이 1--> X
                for (var i = 0; i < outH; i++) 
                for (var k = 0; k < inW ; k++)  
                tmpOutImage[i][k] += 50;
                
                //임시 출력 영상 --> 출력 영상
                for (var i = 0; i < outH; i++) 
                for (var k = 0; k < inW; k++) 
                outImage[i][k] = parseInt(tmpOutImage[i][k]);
                
                
                display();
            }

            //---------------가우시안--------------
            function gaussian() { //가우시안 알고리즘
                // 중요 !마스크 준비 - 화소영역은 마스크만 달라짐
                outH = inH;
                outW = inW;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                //**영상처리 알고리즘 구현
                //**마스크 중요!
                //자바와 다르게 자바스크립트는 3/2= 1.9  ->   자바는 1/ 자바스크립트는 1.9 나누는 그대로 값
                var mask = [    [ 1/16.0 , 1/8.0 , 1/16.0 ],
                                [ 1/8.0 , 1/4.0 , 1/8.0 ],
                                [ 1/16.0 , 1/8.0 , 1/16.0 ]];
                //임시 입력배열( 입력 배열 +2(위아래))
                var tmpInImage = new Array(inH + 2);
                for (var i = 0; i < inH + 2; i++)
                tmpInImage[i] = new Array(inW + 2);

                //임시 입력배열 초기화
                for (var i = 0; i < inH + 2; i++) {
                    for (var k = 0; k < inW + 2; k++) {        
                        tmpInImage[i][k] = 127;   // 개선의 여지가 있음....
                    }
                }
                //입력영상 -> 임시입력영상의 가운데 쏙~
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        tmpInImage[i+1][k+1] = inImage[i][k];
                    }
                        }           

                //임시 출력 영상 준비   -> 데이터값의 손실을 없애기 위해서 임시 출력 영상부분에서 출력전 사전 처리하기위해서
                var tmpOutImage = new Array(outH);
                for (var i = 0; i < outH ; i++)
                    tmpOutImage[i] = new Array(outW);
                    
                    //**영상 처리 알고리즘 --> 회선연산
                    for (var i = 0; i < inH; i++) {
                        for (var k = 0; k < inW; k++) {  
                            //한점에 대해 처리
                            var S = 0; // 
                            for(var m=0; m<3; m++)
                            for(var n=0; n<3; n++)
                            S += tmpInImage[i+m][k+n] * mask[m][n];

                        tmpOutImage[i][k] = S;
                        
                    }
                }
                //임시 출력 영상 --> 출력 영상
                for (var i = 0; i < inH; i++) 
                for (var k = 0; k < inW; k++) 
                outImage[i][k] = parseInt(tmpOutImage[i][k]);
                
                display();
            }
            
            //---------------샤프닝--------------
            function sharpening() { //가우시안 알고리즘
                // 중요 !마스크 준비 - 화소영역은 마스크만 달라짐
                outH = inH;
                outW = inW;
                //영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
                //**영상처리 알고리즘 구현
                //**마스크 중요!
                //자바와 다르게 자바스크립트는 3/2= 1.9  ->   자바는 1/ 자바스크립트는 1.9 나누는 그대로 값
                var mask = [    [ -1.0 , -1.0 , -1.0 ],
                                [ -1.0 , 9.0 , -1.0 ],
                                [ -1.0 , -1.0 , -1.0 ]  ];

                //임시 입력배열( 입력 배열 +2(위아래))
                var tmpInImage = new Array(inH + 2);
                for (var i = 0; i < inH + 2; i++)
                tmpInImage[i] = new Array(inW + 2);

                //임시 입력배열 초기화
                for (var i = 0; i < inH + 2; i++) {
                    for (var k = 0; k < inW + 2; k++) {        
                        tmpInImage[i][k] = 127;   // 개선의 여지가 있음....
                    }
                }
                //입력영상 -> 임시입력영상의 가운데 쏙~
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        tmpInImage[i+1][k+1] = inImage[i][k];
                    }
                        }           

                //임시 출력 영상 준비   -> 데이터값의 손실을 없애기 위해서 임시 출력 영상부분에서 출력전 사전 처리하기위해서
                var tmpOutImage = new Array(outH);
                for (var i = 0; i < outH ; i++)
                    tmpOutImage[i] = new Array(outW);
                    
                    //**영상 처리 알고리즘 --> 회선연산
                    for (var i = 0; i < inH; i++) {
                        for (var k = 0; k < inW; k++) {  
                            //한점에 대해 처리
                            var S = 0; // 9개 곱한 합
                            for(var m=0; m<3; m++)
                                for(var n=0; n<3; n++)
                            S += tmpInImage[i+m][k+n] * mask[m][n];

                        tmpOutImage[i][k] = S;
  
                    }
                }

                
                //임시 출력 영상 --> 출력 영상
                for (var i = 0; i < inH; i++) 
                    for (var k = 0; k < inW; k++) 
                        outImage[i][k] = parseInt(tmpOutImage[i][k]);
                
                
                display();
            }
            //==============================================경계선===============================================
            //---------------엣지--------------
            function edge1() {  // 유사 연산자  화소감산->최대값 결정 ->엣지검출
                // 중요! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                // 출력 영상 크기의 2차원 메모리 확보
                outImage = new Array(outH) ;
                for (var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);

                //임시 입력 배열 ( 입력 배열 + 2)
                var tmpInImage = new Array(inH + 2);
                for(var i=0; i<inH+2; i++) {
                    tmpInImage[i] = new Array(inW + 2);
                        }   

                // 임시 입력 배열 초기화
                for(var i=0; i<inH+2; i++) {
                    for(var k=0; k<inW+2; k++) {   
                        tmpInImage[i][k] = 127; // 개선 ..여지 있음
                        }
                    }

                // 입력영상을 임시입력영상의 가운데 삽입.
                for(var i=0; i<inH; i++) {
                    for(var k=0; k<inW; k++) {   
                        tmpInImage[i+1][k+1] = inImage[i][k];
                        }
                    }
                //임시 출력 영상 준비
                var tmpOutImage = new Array(outH);
                for(var i=0; i<outH; i++) {
                    tmpOutImage[i] = new Array(outW);
                     }
                 // 영상처리 알고리즘 (회선연산)
                for(var i=0; i<inH; i++) {
                    for(var k=0; k<inW; k++) {   
                // 최대값 초기화
                var max = 0.0; 
                for(var m=0; m<3; m++)
                    for(var n=0;n<3;n++)
                        if(tmpInImage[i+1][k+1]-tmpInImage[i+m][k+n] >= max)
                            max = tmpInImage[i+1][k+1] - tmpInImage[i+m][k+n];

                             tmpOutImage[i][k] = max;
                        }
                    }
                // 오버플로우 잡기
                for(var i=0; i<outH; i++) {
                    for(var k=0; k<outW; k++) {  
                       if(tmpOutImage[i][k] >255)
                            tmpOutImage[i][k] = 255;
                        
                       if(tmpOutImage[i][k] <0)
                            tmpOutImage[i][k] = 0;
                    }
                }
                for(var i=0; i<inH; i++) {
                    for(var k=0; k<inW; k++) {  
                        outImage[i][k] = parseInt(tmpOutImage[i][k]);
                    }
                }
                display();
            }

            //---------------엣지--------------
            function edge2() {  // 차 연산자  유사연산자의 계산시간 빠르게
                // 중요! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                // 출력 영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);

                //임시 입력 배열 ( 입력 배열 + 2)
                var tmpInImage = new Array(inH + 2);
                for(var i=0; i<inH+2; i++) {
                    tmpInImage[i] = new Array(inW + 2);
                        }   

                // 임시 입력 배열 초기화
                for(var i=0; i<inH+2; i++) {
                    for(var k=0; k<inW+2; k++) {   
                        tmpInImage[i][k] = 127; // 개선 ..여지 있음
                        }
                    }

                // 입력영상을 임시입력영상의 가운데 삽입.
                for(var i=0; i<inH; i++) {
                    for(var k=0; k<inW; k++) {   
                        tmpInImage[i+1][k+1] = inImage[i][k];
                        }
                    }
                //임시 출력 영상 준비
                var tmpOutImage = new Array(outH);
                for(var i=0; i<outH; i++) {
                    tmpOutImage[i] = new Array(outW);
                     }
                 // 영상처리 알고리즘 (회선연산)
                for(var i=0; i<inH; i++) {
                    for(var k=0; k<inW; k++) {   
                // 최대값 초기화
                        var max = 0.0; 
                        for(var m=0; m<3; m++){
                            if(tmpInImage[i+1][k+m]-tmpInImage[i+2][k+m+2] >= max)
                                max = tmpInImage[i][k+m] - tmpInImage[i+2][k-m+2];
                              }
                            if(tmpInImage[i+1][k]-tmpInImage[i+1][k+2]>=max)
                                max = tmpInImage[i+1][k]-tmpInImage[i+1][k+2];

                                tmpOutImage[i][k] = max;
                                }
                            }
                // 오버플로우 잡기
                for(var i=0; i<outH; i++) {
                    for(var k=0; k<outW; k++) {  
                       if(tmpOutImage[i][k] >255)
                            tmpOutImage[i][k] = 255;
                        
                       if(tmpOutImage[i][k] <0)
                            tmpOutImage[i][k] = 0;
                    }
                }
                for(var i=0; i<inH; i++) {
                    for(var k=0; k<inW; k++) {  
                        outImage[i][k] = parseInt(tmpOutImage[i][k]);
                    }
                }
                display();
            }

            //---------------라플라시안--------------
            function laplacian() { //라플라시안
                var Val = parseInt(prompt("값(1, 2, 3)", 1));
                    // 중요! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                // 출력 영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);

                //화소 영역처리 (마스크)
                var mask1 = [
                    [0, 1, 0],
                    [1, -4, 1],
                    [0, 1, 0]
                ];
                var mask2 = [
                    [1, 1, 1],
                    [1, -8, 1],
                    [1, 1, 1]
                ];
                var mask3 = [
                    [-1, -1, -1],
                    [-1, 8, -1],
                    [-1, -1, -1]
                ];
                if (Val === 1)
                    mask = mask1;
                if (Val === 2)
                    mask = mask2;
                if (Val === 3)
                    mask = mask3;

                //임시 입력 배열
                var tmpInImage = new Array(inH + 2);
                for (var i = 0; i < inH + 2; i++)
                    tmpInImage[i] = new Array(inW + 2);
                // 임시 입력 배열 초기화 (127)
                for (var i = 0; i < inH + 2; i++) {
                    for (var k = 0; k < inW + 2; k++) {
                        tmpInImage[i][k] = 127;
                    }
                }
                // 입력 배열 --> 임시 입력 배열
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        tmpInImage[i + 1][k + 1] = inImage[i][k];
                    }
                }
                // 임시 출력 배열
                var tmpOutImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //*** -> 회산연산
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        var S = 0.0;
                        for (var m = 0; m < 3; m++) {
                            for (var n = 0; n < 3; n++) {
                                S += tmpInImage[i + m][k + n] * mask[m][n];
                            }
                        }
                        tmpOutImage[i][k] = S;
                    }
                }
                // 후처리 작업(마스크 합계가 0 이면 127 정도를 더하기)
                for (var i = 0; i < outH; i++) {
                    for (var k = 0; k < outW; k++) {
                        tmpOutImage[i][k] += 127;
                    }
                }
                // 임시 출력 배열-- > 출력 배열
                for (var i = 0; i < outH; i++) {
                    for (var k = 0; k < outW; k++) {
                        var v = tmpOutImage[i][k];
                        if (v > 255.0)
                            v = 255.0;
                        if (v < 0.0)
                            v = 0.0;
                        outImage[i][k] = parseInt(v);
                    }
                }
                display();
            }

            //---------------도그--------------
            function dog() {    //도그
                //화소 영역처리 (마스크)
                // 중요! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                // 출력 영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                var mask = [
                    [0, 0, 0, -1, -1, -1, 0, 0, 0, ],
                    [0, -2, -3, -3, -3, -3, -3, -2, 0, ],
                    [0, -3, -2, -1, -1, -1, -2, -3, 0, ],
                    [-1, -3, -1, 9, 9, 9, -1, -3, -1, ],
                    [-1, -3, -1, 9, 19, 9, -1, -3, -1, ],
                    [-1, -3, -1, 9, 9, 9, -1, -3, -1, ],
                    [0, -3, -2, -1, -1, -1, -2, -3, 0, ],
                    [0, -2, -3, -3, -3, -3, -3, -2, 0, ],
                    [0, 0, 0, -1, -1, -1, 0, 0, 0, ]
                ];

                //임시 입력 배열
                var tmpInImage = new Array(inH + 8);
                for (var i = 0; i < inH + 8; i++)
                    tmpInImage[i] = new Array(inW + 8);
                // 임시 입력 배열 초기화 (127)
                for (var i = 0; i < inH + 8; i++) {
                    for (var k = 0; k < inW + 8; k++) {
                        tmpInImage[i][k] = 127;
                    }
                }
                // 입력 배열 --> 임시 입력 배열
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        tmpInImage[i + 1][k + 1] = inImage[i][k];
                    }
                }
                // 임시 출력 배열
                var tmpOutImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //*** -> 회산연산
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        var S = 0.0;
                        for (var m = 0; m < 9; m++) {
                            for (var n = 0; n < 9; n++) {
                                S += tmpInImage[i + m][k + n] * mask[m][n];
                            }
                        }
                        tmpOutImage[i][k] = S; //음수는 문자가 없다
                    }
                }
                // 후처리 작업(마스크 합계가 0 이면 127 정도를 더하기)
                for (var i = 0; i < outH; i++) {
                    for (var k = 0; k < outW; k++) {
                        tmpOutImage[i][k] += 127.0;
                    }
                }
                // 임시 출력 배열-- > 출력 배열
                for (var i = 0; i < outH; i++) {
                    for (var k = 0; k < outW; k++) {
                        var v = tmpOutImage[i][k];
                        if (v > 255.0)
                            v = 255.0;
                        if (v < 0.0)
                            v = 0.0;
                        outImage[i][k] = parseInt(v);
                    }
                }
                display();
            }
            //---------------프리잇--------------
            function prewitt() {    //프리잇
                //화소 영역처리 (마스크)
                // 중요! 출력 영상의 크기를 결정 --> 알고리즘에 의존~
                outH = inH;
                outW = inW;
                // 출력 영상 크기의 2차원 메모리 확보
                outImage = new Array(outH);
                for (var i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                var Val = parseInt(prompt("값(1, 2)", 1));
                var maskLow = [
                    [-1, -1, -1],
                    [0, 0, 0],
                    [1, 1, 1]
                ];
                var maskCol = [
                    [1, 0, -1],
                    [1, 0, -1],
                    [1, 0, -1]
                ];
                if (Val === 1)
                    mask = maskLow;
                if (Val === 2)
                    mask = maskCol;

                //임시 입력 배열
                var tmpInImage = new Array(inH + 2);
                for (var i = 0; i < inH + 2; i++)
                    tmpInImage[i] = new Array(inW + 2);
                // 임시 입력 배열 초기화 (127)
                for (var i = 0; i < inH + 2; i++) {
                    for (var k = 0; k < inW + 2; k++) {
                        tmpInImage[i][k] = 127;
                    }
                }
                // 입력 배열 --> 임시 입력 배열
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        tmpInImage[i + 1][k + 1] = inImage[i][k];
                    }
                }
                // 임시 출력 배열
                var tmpOutImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //*** -> 회산연산
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        var S = 0.0;
                        for (var m = 0; m < 3; m++) {
                            for (var n = 0; n < 3; n++) {
                                S += tmpInImage[i + m][k + n] * mask[m][n];
                            }
                        }
                        tmpOutImage[i][k] = S;
                    }
                }
                // 후처리 작업(마스크 합계가 0 이면 127 정도를 더하기)
                for (var i = 0; i < outH; i++) {
                    for (var k = 0; k < outW; k++) {
                        tmpOutImage[i][k] += 127;
                    }
                }
                // 임시 출력 배열-- > 출력 배열
                for (var i = 0; i < outH; i++) {
                    for (var k = 0; k < outW; k++) {
                        var v = tmpOutImage[i][k];
                        if (v > 255.0)
                            v = 255.0;
                        if (v < 0.0)
                            v = 0.0;
                        outImage[i][k] = parseInt(v);
                    }
                }
                display();
            
            }
            /*
            //---------------저주파--------------
            function lowFrequency() {   //저주파
                var alpha = parseInt(prompt("알파 값", 5));
                //화소 영역처리 (마스크)
                var mask = [
                    [1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0],
                    [1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0],
                    [1.0 / 9.0, 1.0 / 9.0, 1.0 / 9.0]
                ];

                //임시 입력 배열
                var tmpInImage = new Array(inH + 2);
                for (var i = 0; i < inH + 2; i++)
                    tmpInImage[i] = new Array(inW + 2);
                // 임시 입력 배열 초기화 (127)
                for (var i = 0; i < inH + 2; i++) {
                    for (var k = 0; k < inW + 2; k++) {
                        tmpInImage[i][k] = 127;
                    }
                }
                // 입력 배열 --> 임시 입력 배열
                console.log("1")
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        tmpInImage[i][k] = Math.floor(alpha * inImage[i][k]) - tmpInImage[i][k];

                    }
                }
                // 임시 출력 배열
                console.log("2")
                var tmpOutImage = new Array(outH);
                for (var i = 0; i < outH; i++)
                    tmpOutImage[i] = new Array(outW);
                //*** -> 회산연산
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        var S = 0.0;
                        for (var m = 0; m < 3; m++) {
                            for (var n = 0; n < 3; n++) {
                                S += tmpInImage[i+m][k+n] * mask[m][n];



                            }
                        }
                        tmpOutImage[i][k] = S; 
                    }
                }
                // 후처리 작업(마스크 합계가 0 이면 127 정도를 더하기)
                console.log("3")
                for (var i = 0; i < outH; i++) {
                    for (var k = 0; k < outW; k++) {
                        tmpOutImage[i][k] += 127;
                    }
                }
                // 임시 출력 배열-- > 출력 배열
                for (var i = 0; i < outH; i++) {
                    for (var k = 0; k < outW; k++) {
                        var v = tmpOutImage[i][k];
                        if (v > 255.0)
                            v = 255.0;
                        if (v < 0.0)
                            v = 0.0;
                        outImage[i][k] =parseInt(v);
                    }
                }
                display();
            }
        
           */
           
        //-------------------------------------------------------------------------------------------
            </script>
            
            </head>
        <body onload="init()">
        <h1>GrayScale Image Pocessing (RC 3)</h1>
        <form>
        <input type="file" id="inFile" onchange="openImage()" /><br><br>
        <select name='pixel' onchange="selectAlgorithm(this.form.pixel)">
            <option value =0>  선택하세요(화소점)  </option>
            <optgroup label="화소점 처리"></optgroup>
            <option value =101>  동일 영상  </option>
            <option value =102>  영상 반전 </option>
            <option value =103>  영상 밝기 </option>
            <option value =104>  파라볼라(Cap) </option>
            
        </select>
        <select name='geo' onchange="selectAlgorithm(this.form.geo)">
            <option value =0>  선택하세요(기하학)  </option>
            <optgroup label="기하학 처리"></optgroup>
            <option value =201>  상하 미러링  </option>
            <option value =202>  좌우 미러링 </option>
            <option value =203>  영상 축소 </option>
            <option value =204>  영상 확대 </option>
            <option value =205>  영상 90도 오른쪽회전 </option>
            <option value =206>  영상 90도 왼쪽회전 </option>
    
        </select>
        <select name='his' onchange="selectAlgorithm(this.form.his)">
            <option value =0>  선택하세요(히스토그램)  </option>
            <optgroup label="히스토그램 처리"></optgroup>
            <option value =301> 히스토그램 스트레칭  </option>
            <option value =302>  엔드-인 탐색 </option>
            <option value =303>  히스토그램 평활화 </option>

        </select>
        <select name='hwa' onchange="selectAlgorithm(this.form.hwa)">
            <option value =0>  선택하세요(화소영역)  </option>
            <optgroup label="화소영역 처리"></optgroup>
            <option value =401>  엠보싱  </option>
            <option value =402>  블러링1 </option>
            <option value =403>  블러링2 </option>
            <option value =404>  블러링3 </option>
            <option value =405>  고주파 필터 </option>
            <option value =406>  가우시안 </option>
            <option value =407>  샤프닝 </option>
        </select>
        <select name='area' onchange="selectAlgorithm(this.form.area)">
            <option value =0>  선택하세요(영역)  </option>
            <optgroup label="경계선 처리"></optgroup>
            <option value =501>  엣지1(유사 연산자) </option>
            <option value =502>  엣지2(차 연산자) </option>
            <option value =503>  라플라시안 </option>
            <option value =504>  DoG </option>
            <option value =505>  prewitt </option>
            <!--<option value =506>  lowFrequency </option>-->
        </select>


        <!--======================================레인지 스크롤=================================-->
        <hr>
        <br>
        <input type="range" id="blurring4" name="blurring" min="1" max="25" step="2" value="블러링" onclick="blurringRange()" />
        <laber for="블러링"><b><i> 블러링 </i></b></laber>
        <input type="range" id="addImage2" name="addImage" min="0" max="255" step="1" value="밝기조절" onclick="addImageRange()" />
        <laber for="밝기조절"><b><i> 밝기조절 </i></b></laber>
        <input type="range" id="zommRange1" name="zommRange" min="0.1" max="2" step="0.01" value="크기조절" onclick="zoomRange()" />
        <laber for="크기조절"><b><i> 크기조절 </i></b></laber>
        <hr>
        <br>
        

        </select>
    </form>
    <br>
        <canvas id="inCanvas" style="background-color: antiquewhite"></canvas>
        <canvas id="outCanvas" style="background-color: aqua"></canvas>
</body>
</html>